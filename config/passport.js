const passport = require("passport");
// passport-local is the username/password strategy

const JwtStrategy = require("passport-jwt").Strategy;
// provides options on where in the request to collect the JWT - header, body, cookie, etc.
const ExtractJwt = require("passport-jwt").ExtractJwt;
// const LocalStrategy = require("passport-local").Strategy;
// const User = require("../models/userModel");

const prisma = require("../config/prismaClient");

// note, passport documentation is recognised as being poor
// best location is: https://www.passportjs.org/tutorials/password/
// this series explains it all very well: https://www.youtube.com/watch?v=o6mSdG09yOU&list=PLYQSCk-qyTW2ewJ05f_GKHtTIzjynDgjK&index=9
// The JWT strategy is covered mainly in 9 and 10, but uses knowledge in 7 and 8.
// The strategy also requires the local strategy for general registration and login of users - covered in 5 and 6

/**
 * Process for JWT-based authorization
 *
 * Stage 1 - user registers with username and password:
 * - local strategy generates the salt and password hash, storing both for the user (database)
 * Stage 2 - user logs in with username and password:
 * - local strategy compares:
 *  - the expected password hash from the provided password and the stored salt;
 *  - the stored password hash
 * - if they match, the user is authenticated and a JWT is generated and sent to the user through the response
 * Stage 3 - user client stores the JWT locally - e.g. cookie or local storage
 * Stage 4 - user requests something from server:
 * - JWT sent (normally) in request header
 * - server verifies the token - that it has not been tampered with, and that the user is who they say they are
 * - server decodes the payload in the JWT to get the user's id
 * - server stores the user object ready for use
 * - then the server authorization logic (e.g. are they normal or admin user) is applied
 * Stage 5 - if authorized, the information is sent back to the user
 *
 */

// For authentication, the JWT was generated by private key, and is validated using the public key
const PUBLIC_KEY = process.env.RSA_PUBLIC_KEY;

// At a minimum, `jwtFromRequest` and `secretOrKey` properties
const options = {
  jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(), // Expects "Bearer <token>"
  secretOrKey: PUBLIC_KEY,
  algorithms: ["RS256"],
};

const verifyCallback = (payload, callback) => {
  // Approach here is to use payload.sub which was set as the mongodb _id for the user
  // This checks the db to ensure that the user is still current
  // This approach essentially means that the authorization is carried out by the database:
  // - e.g. if the user was deleted, they would not be authorized

  // An alternative approach would be let the JWT itself drive the authorization
  // The payload would include the roles, then we would instead return the payload in the callback directly
  // without any calls to the database, and the roles and expiry date would determine the authorization

  // NOTE: callback returns a new property user to the second parameter, so it can be used in the middleware stack

  prisma.user
    .findOne({ id: payload.sub })
    // User.findOne({ _id: payload.sub })
    .then((user) => {
      if (!user) {
        return callback(null, false); // no error, but also no username - reject
      }

      // local strat needed to validate the password, but at this stage, the JWT has already been validated
      if (user) {
        return callback(null, user); // no error, return the user - accept
      } else {
        return callback(null, false); // no error, return false - reject
      }
    })
    .catch((err) => {
      callback(err, null); // return an error, passport will handle
    });
};

const strategy = new JwtStrategy(options, verifyCallback);

module.exports = (passport) => {
  passport.use(strategy);
};
